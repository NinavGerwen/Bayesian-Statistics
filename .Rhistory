mu1 <- 1
sigma1 <- 10000
mu2 <- 1
sigma2 <- 10000
Analysis.2 <- GibbsSampler(dat$IQ, dat$verbal, dat$SES, burn.in = 5000,
iterations = 25000, initial.values = c(1, 1, 1))
## Analysis 3: Independent MH Sampler ------------------------------------------
Analysis.3 <- GibbsSampler(dat$IQ, dat$verbal, dat$SES, burn.in = 5000,
iterations = 25000, initial.values = c(1, 1, 1),
method = c("1", "1", "1"))
View(Analysis.3)
Analysis.3$
as
Analysis.3[1]
Analysis.3[4]
Analysis.3[5]
Analysis.3[3]
Analysis.3[2]
mean(Analysis.1[1]$b0)
mean(Analysis.1[1]$b0)
LR1.dataframe <- Analysis.1[1]
View(LR1.dataframe)
LR1.dataframe <- as.dataframe(Analysis.1[1])
View(Analysis.1)
LR1.dataframe <- Analysis.1[[1]]
View(LR1.dataframe)
## Now, to get the expected value of every regression coefficient:
mean(LR1.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
## Now, to get the expected value and credible intervals of every regression coefficient:
mean(LR1.dataframe$b0)
## First, subset the dataframe from the list of output
LR1.dataframe <- Analysis.1[[1]]
## Now, to get the expected value and credible intervals of every regression coefficient:
mean(LR1.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR1.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR1.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
mean(LR1.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR1.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR1.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
## THIRD ANALYSIS --------------------------------------------------------------
LR3.dataframe <- Analysis.3[[1]]
LR3.dataframe <- Analysis.3[[1]]
mean(LR3.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR3.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR3.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
LR3.dataframe <- Analysis.3[[1]]
mean(LR3.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR3.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR3.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
Analysis.3[3]
## Now, to get the expected value and credible intervals of every regression coefficient:
mean(LR1.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR1.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR1.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
## SECOND ANALYSIS -------------------------------------------------------------
## THIRD ANALYSIS --------------------------------------------------------------
LR3.dataframe <- Analysis.3[[1]]
mean(LR3.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR3.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR3.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
LR3.dataframe <- Analysis.3[[1]]
mean(LR3.dataframe$b0)
quantile(LR1.dataframe$b0, probs = c(0.025, 0.975))
mean(LR3.dataframe$b1)
quantile(LR1.dataframe$b1, probs = c(0.025, 0.975))
mean(LR3.dataframe$b2)
quantile(LR1.dataframe$b2, probs = c(0.025, 0.975))
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- cor(matrix[, 1], matrix[, 2])[1]
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
plot(1:lag, autocors)
return(autocors)
}
Analysis[[2]]
Analysis.1[[2]]
View(Analysis.1)
## Convergence for the first analysis ------------------------------------------
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
?plot
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- cor(matrix[, 1], matrix[, 2])[1]
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
plot(1:lag, autocors, ylim = c(-1, 1))
return(autocors)
}
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$b2)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- cor(matrix[, 1], matrix[, 2])[1]
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(-1, 1))
return(autocorplot)
}
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
par(mfrow = c(2, 2))
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## Convergence for the second analysis -----------------------------------------
Analysis.2[[2]]
Analysis.2[[3]]
Analysis.2[[4]]
Analysis.2[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR2.dataframe$b0)
par(mfrow = c(2, 2))
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
Analysis.3[[2]]
Analysis.3[[3]]
Analysis.3[[4]]
Analysis.3[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR3.dataframe$b0)
autocorrelationplot(V = LR3.dataframe$b1)
autocorrelationplot(V = LR3.dataframe$b2)
autocorrelationplot(V = LR3.dataframe$vari)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- abs(cor(matrix[, 1], matrix[, 2])[1])
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(-1, 1))
return(autocorplot)
}
par(mfrow = c(2, 2))
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- abs(cor(matrix[, 1], matrix[, 2])[1])
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(-1, 1)) abline(h = 0)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- abs(cor(matrix[, 1], matrix[, 2])[1])
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(-1, 1)) +
abline(h = 0)
return(autocorplot)
}
par(mfrow = c(2, 2))
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- abs(cor(matrix[, 1], matrix[, 2])[1])
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(0, 1)) +
abline(h = 0)
return(autocorplot)
}
par(mfrow = c(2, 2))
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## Autocorrelation plot function:
## For input: the autocorrelation plot should require a vector
## and the total amount of lags they wish to have (by default 50)
autocorrelationplot <- function(V, lag = 50) {
## First, it creates space for the values of the autocorrelations
autocors <- rep(NA, lag)
## Then, a for loop is created that lasts up to the specified lag
for(i in 1:lag) {
## First, it creates two versions of the given vector, where
## in the first version, there are i * 0's added at the end
## and in the second version, there are i * 0's added at the beginning
V1 <- c(V, rep(0, i))
V2 <- c(rep(0, i), V)
## Then, the two versions are put into a matrix
matrix <- cbind(V1, V2)
## Then, we remove the i elements at the top and the bottom
## This is done so that the two vectors are of the same length
## and the values for which there is no lagged version are removed
## example: the third sampled value can not have a lag greater than 3
matrix <- head(matrix, -i)
matrix <- tail(matrix, -i)
## Finally, we ask for the correlation between the two vectors
## and put it in the created space
autocors[i] <- abs(cor(matrix[, 1], matrix[, 2])[1])
}
## Then, the autocorrelation plot is created with the lag on x-axis
## and the correlation values on the y-axis
autocorplot <- plot(1:lag, autocors, ylim = c(0, 1))
return(autocorplot)
}
par(mfrow = c(2, 2))
## Convergence for the first analysis ------------------------------------------
## TRACEPLOTS
Analysis.1[[2]]
Analysis.1[[3]]
Analysis.1[[4]]
Analysis.1[[5]]
## AUTOCOR PLOTS
autocorrelationplot(V = LR1.dataframe$b0)
autocorrelationplot(V = LR1.dataframe$b1)
autocorrelationplot(V = LR1.dataframe$b2)
autocorrelationplot(V = LR1.dataframe$vari)
## First, we set a seed for reproducibility
set.seed(3)
## Then, we create an empty matrix with equal rows to our original dataset
## and as many columns as we would like datasets
sim.data <- matrix(data = NA, nrow = 400, ncol = 1000)
## Then, we create space for the regression coefficients that we will sample
## so that we can use these to calculate the residuals later
b0_t <- rep(NA, 1000)
b1_t <- rep(NA, 1000)
b2_t <- rep(NA, 1000)
s2_t <- rep(NA, 1000)
## Now, we can start the data simulation through a for loop
for(i in 1:1000) {
## In every loop, we sample one value from all our regression coefficients
b0_t[i] <- sample(LRX.dataframe$b0, 1)
b1_t[i] <- sample(LRX.dataframe$b1, 1)
b2_t[i] <- sample(LRX.dataframe$b2, 1)
s2_t[i] <- sample(LRX.dataframe$vari, 1)
## Then, we create a column of simulated Y values that use the sampled
## regression coefficients through rnorm, where the mean is their
## expected value and the sd is the sampled variance
sim.data[, i] <- rnorm(400, mean = b0_t[i] + b1_t[i]*testdat$verbal + b2_t[i]*testdat$SES, sd = sqrt(s2_t[i]))
}
library(MASS)
linearmodel <- lm(IQ ~ verbal + SES, data = dat)
vcov(LR1.dataframe)
cov(LR1.dataframe)
var(LR1.dataframe)
var(LR1.dataframe[1:3])
## Create a linear mo
linearmodel <- lm(IQ ~ verbal + SES, data = dat)
vcov(linearmodel)
vcov(linearmodel)[2:3]
vcov(linearmodel)[2:3, 2:3]
## OPTIE 2
Sigma <- cov(LR1.dataframe[2:3])
View(Sigma)
Sigma
library(MASS)
## Create a linear mo
linearmodel <- lm(IQ ~ verbal + SES, data = dat)
## OPTIES VOOR SAMPLING:
## OPTIE 1
Means <- linearmodel$coefficients[2:3]
Sigma <- vcov(linearmodel)[2:3, 2:3]
set.seed(3)
posterior <- mvrnorm(100000, mu = Means, Sigma = sigma)
set.seed(3)
posterior <- mvrnorm(100000, mu = Means, Sigma = sigma)
post <- mvrnorm(100000, mu = means, Sigma = sigma)
set.seed(3)
posterior <- mvrnorm(100000, mu = Means, Sigma = sigma)
set.seed(3)
posterior <- mvrnorm(100000, mu = Means, Sigma = Sigma)
set.seed(3)
posterior <- mvrnorm(100000, mu = Means, Sigma = Sigma)
## Calculate the fractional value
b <- 6/400 ## 3 regression coefficients: 3 means, 3 variances --> 6
prior <- mvrnorm(100000, mu = c(0, 0), Sigma = Sigma/b)
BF.H1 <- (sum(post[, 1] > 0 & post[, 2] > 0)/100000) /
(sum(prior[, 1] > 0 & prior[, 2] > 0)/100000)
BF.H1 <- (sum(posterior[, 1] > 0 & posterior[, 2] > 0)/100000) /
(sum(prior[, 1] > 0 & prior[, 2] > 0)/100000)
BF.H2 <- (sum(posterior[, 1] > 0 & posterior[, 2] < .1 & posterior[, 2] > -.1)/100000) /
(sum(prior[, 1] > 0 & prior[, 2] < .1 & prior[, 2] > -.1)/100000)
BF.H3 <- (sum(posterior[, 2] > 0 & posterior[, 1] < .1 & posterior[, 1] > -.1)/100000) /
(sum(prior[, 2] > 0 & prior[, 1] < .1 & prior[, 1] > -.1)/100000)
